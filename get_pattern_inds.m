function [idf, idt, iuf, iut, ilf, ilt, irf, irt] = get_pattern_inds(pattern)
% This is a helper function that determines where all of the boundaries of
% the light pattern are located. These are returned as indices FROM and
% indices TO, representing the directions of flux. 
%
% Inputs
% pattern - a binary mask of the light input
% 
% Outputs
% idf     - flux downward FROM these indices
% idt     - flux downward TO these indices
% iuf     - flux upward FROM these indices
% iut     - flux upward TO these indices
% ilf     - flux leftward FROM these indices
% ilt     - flux leftward TO these indices
% irf     - flux rightward FROM these indices
% irt     - flux rightward TO these indices

%% Get illumination pattern

% Pattern can be generated by:
% pattern = roipoly(N,N);

%% Now you have an illumination pattern, find 2D boundaries with flux left, right, up, down
% This is done using a convolution operator looking for an edge in either the up/down 
% or left/right direction. We use the conv2() function and a kernel of [1 0 -1] to detect 
% edges. Rising or falling edges return a negative or positive sign, respectively.
inds_down  = find(conv2(pattern, [1;0;-1], 'same') > 0);
inds_up    = find(conv2(pattern, [1;0;-1], 'same') < 0);
inds_right = find(conv2(pattern, [1 0 -1], 'same') > 0);
inds_left  = find(conv2(pattern, [1 0 -1], 'same') < 0);

%% gets the indices of pattern boundaries for each direction of flux
sz = size(pattern);

% Now we convert the indices of changes to subscripts (i,j)
[id,jd]   = ind2sub(sz, inds_down);
[iu,ju]   = ind2sub(sz, inds_up);
[ir,jr]   = ind2sub(sz, inds_right);
[il,jl]   = ind2sub(sz, inds_left);

% Next, we find the neighboring boxes to the box where the boundary is. 
% This is where flux is coming FROM.
idt = inds_down;
idf = sub2ind(sz, id-1,jd);
iut = inds_up;
iuf = sub2ind(sz, iu+1,ju);
ilt = inds_left;
ilf = sub2ind(sz, il,jl+1);
irt = inds_right;
irf = sub2ind(sz, ir,jr-1);

% We will implement these equations in our ODE:
%         % Flux upwards:
%         dydt(iu+1,ju) = dydt(iu+1,ju) - f*y(iu+1,ju); % flux FROM
%         dydt(iu,ju)   = dydt(iu,ju)   + f*y(iu+1,ju); % flux TO
%         % Flux downwards:
%         dydt(id-1,jd) = dydt(id-1,jd) + f*y(id-1,jd); % flux FROM
%         dydt(id,jd)   = dydt(id,jd)   + f*y(id-1,jd); % flux TO
%         % Flux leftwards:
%         dydt(il,jl+1) = dydt(il,jl+1) - f*y(il,jl+1); % flux FROM
%         dydt(il,jl)   = dydt(il,jl)   + f*y(il,jl+1); % flux TO
%         % Flux rightwards:
%         dydt(ir,jr-1) = dydt(ir,jr-1) - f*y(ir,jr-1); % flux FROM
%         dydt(ir,jr)   = dydt(ir,jr)   + f*y(ir,jr-1); % flux TO
return

%% sanity check: can plot the results
% This code is not run, but it is useful for checking whether you have the indices right!!
tmp = zeros(N,N);
for k = 1:length(idown)
    tmp(idown(k), jdown(k)) = 1;
end
for k = 1:length(iup)
    tmp(iup(k), jup(k)) = 2;
end
for k = 1:length(iright)
    tmp(iright(k), jright(k)) = 3;
end
for k = 1:length(ileft)
    tmp(ileft(k), jleft(k)) = 4;
end
imagesc(tmp), colorbar
